// World countries with coordinates
export const worldCountries = [
  { name: 'Afghanistan', lat: 33.9391, lon: 67.7100, code: 'AF' },
  { name: 'Albania', lat: 41.1533, lon: 20.1683, code: 'AL' },
  { name: 'Algeria', lat: 28.0339, lon: 1.6596, code: 'DZ' },
  { name: 'Argentina', lat: -38.4161, lon: -63.6167, code: 'AR' },
  { name: 'Armenia', lat: 40.0691, lon: 45.0382, code: 'AM' },
  { name: 'Australia', lat: -25.2744, lon: 133.7751, code: 'AU' },
  { name: 'Austria', lat: 47.5162, lon: 14.5501, code: 'AT' },
  { name: 'Azerbaijan', lat: 40.1431, lon: 47.5769, code: 'AZ' },
  { name: 'Bangladesh', lat: 23.6850, lon: 90.3563, code: 'BD' },
  { name: 'Belarus', lat: 53.7098, lon: 27.9534, code: 'BY' },
  { name: 'Belgium', lat: 50.5039, lon: 4.4699, code: 'BE' },
  { name: 'Bolivia', lat: -16.2902, lon: -63.5887, code: 'BO' },
  { name: 'Brazil', lat: -14.2350, lon: -51.9253, code: 'BR' },
  { name: 'Bulgaria', lat: 42.7339, lon: 25.4858, code: 'BG' },
  { name: 'Cambodia', lat: 12.5657, lon: 104.9910, code: 'KH' },
  { name: 'Cameroon', lat: 7.3697, lon: 12.3547, code: 'CM' },
  { name: 'Canada', lat: 56.1304, lon: -106.3468, code: 'CA' },
  { name: 'Chad', lat: 15.4542, lon: 18.7322, code: 'TD' },
  { name: 'Chile', lat: -35.6751, lon: -71.5430, code: 'CL' },
  { name: 'China', lat: 35.8617, lon: 104.1954, code: 'CN' },
  { name: 'Colombia', lat: 4.5709, lon: -74.2973, code: 'CO' },
  { name: 'Democratic Republic of Congo', lat: -4.0383, lon: 21.7587, code: 'CD' },
  { name: 'Czech Republic', lat: 49.8175, lon: 15.4730, code: 'CZ' },
  { name: 'Denmark', lat: 56.2639, lon: 9.5018, code: 'DK' },
  { name: 'Egypt', lat: 26.0975, lon: 31.2357, code: 'EG' },
  { name: 'Ethiopia', lat: 9.1450, lon: 40.4897, code: 'ET' },
  { name: 'Finland', lat: 61.9241, lon: 25.7482, code: 'FI' },
  { name: 'France', lat: 46.2276, lon: 2.2137, code: 'FR' },
  { name: 'Germany', lat: 51.1657, lon: 10.4515, code: 'DE' },
  { name: 'Ghana', lat: 7.9465, lon: -1.0232, code: 'GH' },
  { name: 'Greece', lat: 39.0742, lon: 21.8243, code: 'GR' },
  { name: 'Hungary', lat: 47.1625, lon: 19.5033, code: 'HU' },
  { name: 'India', lat: 20.5937, lon: 78.9629, code: 'IN' },
  { name: 'Indonesia', lat: -0.7893, lon: 113.9213, code: 'ID' },
  { name: 'Iran', lat: 32.4279, lon: 53.6880, code: 'IR' },
  { name: 'Iraq', lat: 33.2232, lon: 43.6793, code: 'IQ' },
  { name: 'Ireland', lat: 53.4129, lon: -8.2439, code: 'IE' },
  { name: 'Israel', lat: 31.0461, lon: 34.8516, code: 'IL' },
  { name: 'Italy', lat: 41.8719, lon: 12.5674, code: 'IT' },
  { name: 'Japan', lat: 36.2048, lon: 138.2529, code: 'JP' },
  { name: 'Kazakhstan', lat: 48.0196, lon: 66.9237, code: 'KZ' },
  { name: 'Kenya', lat: -0.0236, lon: 37.9062, code: 'KE' },
  { name: 'Libya', lat: 26.3351, lon: 17.2283, code: 'LY' },
  { name: 'Madagascar', lat: -18.7669, lon: 46.8691, code: 'MG' },
  { name: 'Mali', lat: 17.5707, lon: -3.9962, code: 'ML' },
  { name: 'Mexico', lat: 23.6345, lon: -102.5528, code: 'MX' },
  { name: 'Mongolia', lat: 46.8625, lon: 103.8467, code: 'MN' },
  { name: 'Morocco', lat: 31.7917, lon: -7.0926, code: 'MA' },
  { name: 'Myanmar', lat: 21.9162, lon: 95.9560, code: 'MM' },
  { name: 'Netherlands', lat: 52.1326, lon: 5.2913, code: 'NL' },
  { name: 'Niger', lat: 17.6078, lon: 8.0817, code: 'NE' },
  { name: 'Nigeria', lat: 9.0820, lon: 8.6753, code: 'NG' },
  { name: 'Norway', lat: 60.4720, lon: 8.4689, code: 'NO' },
  { name: 'Pakistan', lat: 30.3753, lon: 69.3451, code: 'PK' },
  { name: 'Peru', lat: -9.1900, lon: -75.0152, code: 'PE' },
  { name: 'Philippines', lat: 12.8797, lon: 121.7740, code: 'PH' },
  { name: 'Poland', lat: 51.9194, lon: 19.1451, code: 'PL' },
  { name: 'Romania', lat: 45.9432, lon: 24.9668, code: 'RO' },
  { name: 'Russia', lat: 61.5240, lon: 105.3188, code: 'RU' },
  { name: 'Saudi Arabia', lat: 23.8859, lon: 45.0792, code: 'SA' },
  { name: 'South Africa', lat: -30.5595, lon: 22.9375, code: 'ZA' },
  { name: 'South Korea', lat: 35.9078, lon: 127.7669, code: 'KR' },
  { name: 'Spain', lat: 40.4637, lon: -3.7492, code: 'ES' },
  { name: 'Sudan', lat: 12.8628, lon: 30.2176, code: 'SD' },
  { name: 'Sweden', lat: 60.1282, lon: 18.6435, code: 'SE' },
  { name: 'Thailand', lat: 15.8700, lon: 100.9925, code: 'TH' },
  { name: 'Turkey', lat: 38.9637, lon: 35.2433, code: 'TR' },
  { name: 'Ukraine', lat: 48.3794, lon: 31.1656, code: 'UA' },
  { name: 'United Kingdom', lat: 55.3781, lon: -3.4360, code: 'GB' },
  { name: 'United States', lat: 39.8283, lon: -98.5795, code: 'US' },
  { name: 'Uzbekistan', lat: 41.3775, lon: 64.5853, code: 'UZ' },
  { name: 'Venezuela', lat: 6.4238, lon: -66.5897, code: 'VE' },
  { name: 'Vietnam', lat: 14.0583, lon: 108.2772, code: 'VN' },
  { name: 'Yemen', lat: 15.5527, lon: 48.5164, code: 'YE' },
  { name: 'Zambia', lat: -13.1339, lon: 27.8493, code: 'ZM' }
];

// Available crops with their characteristics
export const crops = [
  {
    id: 'wheat',
    name: 'Wheat',
    icon: 'üåæ',
    optimalTemp: [15, 25],
    waterNeed: 500,
    description: 'Cool season grain crop - Great for temperate climates'
  },
  {
    id: 'rice',
    name: 'Rice',
    icon: 'üçö',
    optimalTemp: [20, 35],
    waterNeed: 1200,
    description: 'Water-intensive staple grain - Needs lots of water'
  },
  {
    id: 'maize',
    name: 'Corn',
    icon: 'üåΩ',
    optimalTemp: [18, 30],
    waterNeed: 600,
    description: 'Warm season cereal grain - Versatile crop'
  },
  {
    id: 'sorghum',
    name: 'Sorghum',
    icon: 'üåæ',
    optimalTemp: [25, 35],
    waterNeed: 400,
    description: 'Drought-tolerant grain - Perfect for dry areas'
  },
  {
    id: 'soybeans',
    name: 'Soybeans',
    icon: 'ü´õ',
    optimalTemp: [20, 30],
    waterNeed: 500,
    description: 'Protein-rich legume - Improves soil naturally'
  }
];

/**
 * Fetch NASA POWER API data for a given location
 * @param {number} lat - Latitude
 * @param {number} lon - Longitude
 * @returns {Promise<Object>} Weather and climate data
 */
export const fetchNASAData = async (lat, lon) => {
  try {
    const startDate = '20230101';
    const endDate = '20231231';
    
    const powerUrl = `https://power.larc.nasa.gov/api/temporal/daily/point?parameters=T2M,PRECTOTCORR,ALLSKY_SFC_SW_DWN&community=AG&longitude=${lon}&latitude=${lat}&start=${startDate}&end=${endDate}&format=JSON`;
    
    const response = await fetch(powerUrl);
    if (!response.ok) {
      throw new Error(`NASA POWER API error: ${response.status} ${response.statusText}`);
    }
    
    const data = await response.json();
    
    // Validate response data
    if (!data.properties || !data.properties.parameter) {
      throw new Error('Invalid response format from NASA API');
    }
    
    const tempData = Object.values(data.properties.parameter.T2M || {});
    const precipData = Object.values(data.properties.parameter.PRECTOTCORR || {});
    const solarData = Object.values(data.properties.parameter.ALLSKY_SFC_SW_DWN || {});
    
    if (tempData.length === 0 || precipData.length === 0 || solarData.length === 0) {
      throw new Error('Incomplete data from NASA API');
    }
    
    // Calculate averages and totals
    const avgTemp = tempData.reduce((a, b) => a + b, 0) / tempData.length;
    const totalPrecip = precipData.reduce((a, b) => a + b, 0);
    const avgSolar = solarData.reduce((a, b) => a + b, 0) / solarData.length;
    
    // Calculate a simplified NDVI estimate based on climate factors
    const ndvi = Math.max(0.1, Math.min(0.9, 
      (totalPrecip / 1000) * (1 - Math.abs(avgTemp - 25) / 25)
    ));
    
    return {
      temperature: Math.round(avgTemp * 10) / 10,
      precipitation: Math.round(totalPrecip * 10) / 10,
      solar: Math.round(avgSolar * 10) / 10,
      ndvi: Math.round(ndvi * 100) / 100
    };
  } catch (error) {
    console.warn('Error fetching NASA data:', error.message);
    
    // Return fallback mock data based on location
    const latFactor = Math.abs(lat) / 90;  // 0 to 1, higher near poles
    const baseTemp = 30 - (latFactor * 25); // Cooler near poles
    const basePrecip = 800 - (latFactor * 400); // Less precipitation near poles
    
    return {
      temperature: Math.round((baseTemp + (Math.random() - 0.5) * 10) * 10) / 10,
      precipitation: Math.round((basePrecip + (Math.random() - 0.5) * 600) * 10) / 10,
      solar: Math.round((180 - latFactor * 50 + Math.random() * 80) * 10) / 10,
      ndvi: Math.round((0.4 + Math.random() * 0.4) * 100) / 100
    };
  }
};

/**
 * Determine climate type based on temperature and precipitation
 * @param {number} temp - Average temperature
 * @param {number} precip - Annual precipitation
 * @returns {string} Climate description with emoji
 */
export const getClimateType = (temp, precip) => {
  if (temp > 25 && precip < 500) return 'Hot & Dry üèúÔ∏è';
  if (temp > 25 && precip >= 500) return 'Hot & Wet üå¥';
  if (temp >= 15 && temp <= 25 && precip >= 500) return 'Mild & Wet üåø';
  if (temp >= 15 && temp <= 25 && precip < 500) return 'Mild & Dry üå±';
  if (temp < 15) return 'Cool ‚ùÑÔ∏è';
  return 'Variable üåç';
};

/**
 * Generate relevant alerts for a country based on its climate data
 * @param {Object} country - Country object with climate data
 * @returns {Array} Array of alert objects
 */
export const generateAlerts = (country) => {
  const alerts = [];
  
  // Heavy rain alert
  if (country.precipitation > 1200) {
    alerts.push({
      type: 'rain',
      title: 'Heavy Rain Alert',
      message: `High rainfall expected (${country.precipitation}mm). Consider drainage and flood protection for crops.`,
      severity: 'warning'
    });
  }
  
  // Drought alert
  if (country.precipitation < 300) {
    alerts.push({
      type: 'drought',
      title: 'Drought Warning',
      message: `Low rainfall detected (${country.precipitation}mm). Irrigation systems strongly recommended.`,
      severity: 'danger'
    });
  }
  
  // Earthquake risk (simulated based on certain regions known for seismic activity)
  const earthquakeRiskCountries = ['JP', 'CL', 'TR', 'PH', 'ID', 'IT', 'GR', 'NZ', 'MX'];
  if (earthquakeRiskCountries.includes(country.code)) {
    alerts.push({
      type: 'earthquake',
      title: 'Earthquake Risk Zone',
      message: `This region has seismic activity. Consider earthquake-resistant farming structures and emergency plans.`,
      severity: 'info'
    });
  }
  
  // Extreme temperature alerts
  if (country.temperature > 35) {
    alerts.push({
      type: 'heat',
      title: 'Extreme Heat Alert',
      message: `High temperatures (${country.temperature}¬∞C). Crops may need shade protection and extra water.`,
      severity: 'danger'
    });
  }
  
  if (country.temperature < 5) {
    alerts.push({
      type: 'cold',
      title: 'Frost Warning',
      message: `Cold temperatures (${country.temperature}¬∞C). Protect crops from frost damage with covers or greenhouses.`,
      severity: 'warning'
    });
  }
  
  // Moderate drought alert
  if (country.precipitation >= 300 && country.precipitation < 500) {
    alerts.push({
      type: 'drought',
      title: 'Water Conservation Notice',
      message: `Moderate rainfall (${country.precipitation}mm). Consider water-efficient crops and conservation practices.`,
      severity: 'info'
    });
  }
  
  // High solar radiation
  if (country.solar > 250) {
    alerts.push({
      type: 'heat',
      title: 'High Solar Radiation',
      message: `Intense sunlight (${country.solar} W/m¬≤). Great for solar-loving crops but may require crop protection.`,
      severity: 'info'
    });
  }
  
  return alerts;
};

/**
 * Utility function to delay execution
 * @param {number} ms - Milliseconds to delay
 * @returns {Promise} Promise that resolves after the delay
 */
export const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

/**
 * Format number with appropriate units and decimal places
 * @param {number} value - Number to format
 * @param {string} unit - Unit to append
 * @param {number} decimals - Number of decimal places
 * @returns {string} Formatted string
 */
export const formatValue = (value, unit = '', decimals = 1) => {
  return `${Number(value).toFixed(decimals)}${unit}`;
};

/**
 * Calculate crop compatibility score
 * @param {Object} crop - Crop object
 * @param {Object} country - Country climate data
 * @returns {Object} Compatibility analysis
 */
export const calculateCropCompatibility = (crop, country) => {
  const tempOptimal = country.temperature >= crop.optimalTemp[0] && 
                     country.temperature <= crop.optimalTemp[1];
  const waterSufficient = country.precipitation >= crop.waterNeed * 0.7;
  
  let score = 0;
  let factors = [];
  
  // Temperature scoring
  if (tempOptimal) {
    score += 50;
    factors.push('Temperature: Optimal');
  } else {
    const tempDeviation = Math.min(
      Math.abs(country.temperature - crop.optimalTemp[0]),
      Math.abs(country.temperature - crop.optimalTemp[1])
    );
    const tempScore = Math.max(0, 50 - tempDeviation * 5);
    score += tempScore;
    factors.push(`Temperature: ${tempScore > 25 ? 'Acceptable' : 'Challenging'}`);
  }
  
  // Water scoring
  if (waterSufficient) {
    score += 40;
    factors.push('Water: Sufficient');
  } else {
    const waterRatio = country.precipitation / crop.waterNeed;
    const waterScore = Math.max(0, 40 * waterRatio);
    score += waterScore;
    factors.push(`Water: ${waterScore > 20 ? 'Limited' : 'Insufficient'}`);
  }
  
  // NDVI bonus
  const ndviBonus = country.ndvi * 10;
  score += ndviBonus;
  factors.push(`Vegetation Health: ${country.ndvi > 0.6 ? 'Excellent' : country.ndvi > 0.4 ? 'Good' : 'Poor'}`);
  
  return {
    score: Math.round(score),
    level: score > 80 ? 'excellent' : score > 60 ? 'good' : score > 40 ? 'fair' : 'poor',
    factors,
    tempOptimal,
    waterSufficient
  };
};

/**
 * Get seasonal recommendations based on country and time
 * @param {Object} country - Country data
 * @param {number} season - Current season number
 * @returns {Array} Array of recommendation strings
 */
export const getSeasonalRecommendations = (country, season) => {
  const recommendations = [];
  
  // Climate-based recommendations
  if (country.climate.includes('Dry')) {
    recommendations.push('Consider drought-resistant crops like sorghum');
    recommendations.push('Implement water-saving irrigation techniques');
  }
  
  if (country.climate.includes('Wet')) {
    recommendations.push('Ensure good drainage to prevent waterlogging');
    recommendations.push('Watch for fungal diseases in high humidity');
  }
  
  if (country.temperature > 30) {
    recommendations.push('Provide shade protection during peak heat');
    recommendations.push('Schedule activities for cooler parts of the day');
  }
  
  if (country.temperature < 10) {
    recommendations.push('Use row covers or greenhouses for protection');
    recommendations.push('Choose cold-tolerant varieties');
  }
  
  // Season-specific advice
  if (season > 3) {
    recommendations.push('Consider crop rotation to maintain soil health');
    recommendations.push('Monitor for pest build-up from previous seasons');
  }
  
  if (season > 5) {
    recommendations.push('Evaluate long-term sustainability practices');
    recommendations.push('Consider cover crops to restore soil nutrients');
  }
  
  return recommendations;
};

/**
 * Generate educational facts about farming and climate
 * @returns {Array} Array of educational facts
 */
export const getEducationalFacts = () => {
  return [
    "NASA satellites monitor crop health worldwide using vegetation indices",
    "Climate change is shifting optimal growing zones for many crops poleward",
    "Precision agriculture can reduce water usage by up to 30%",
    "Cover crops can improve soil health and reduce erosion by 90%",
    "Drought-tolerant crops can maintain yields with 40% less water",
    "Crop rotation helps break pest cycles and improves soil fertility",
    "Remote sensing helps farmers optimize irrigation and fertilizer use",
    "Sustainable farming practices can increase long-term profitability",
    "Soil health directly impacts crop nutrition and yield potential",
    "Weather data helps farmers time planting and harvesting optimally"
  ];
};

/**
 * Calculate environmental impact score
 * @param {Object} farmingChoices - Object containing irrigation, fertilizer, and crop choices
 * @param {Object} results - Farming results object
 * @returns {Object} Environmental impact analysis
 */
export const calculateEnvironmentalImpact = (farmingChoices, results) => {
  let carbonFootprint = 100; // Base score
  let waterImpact = results.waterUsage;
  let soilImpact = results.soilHealth;
  let biodiversityImpact = 100;
  
  // Irrigation impact
  if (farmingChoices.irrigation) {
    carbonFootprint += 15; // Energy for pumping
    waterImpact += 200; // Additional water use
    if (results.waterStress) {
      biodiversityImpact -= 10; // Less impact if needed
    } else {
      biodiversityImpact -= 20; // More impact if not needed
    }
  }
  
  // Fertilizer impact
  if (farmingChoices.fertilizer) {
    carbonFootprint += 25; // Production and transport
    soilImpact -= 15; // Long-term soil health
    biodiversityImpact -= 15; // Runoff effects
    
    if (farmingChoices.selectedCrop === 'soybeans') {
      carbonFootprint += 10; // Unnecessary for nitrogen-fixing crops
    }
  }
  
  // Crop-specific impacts
  const cropImpacts = {
    'rice': { carbon: 20, water: 300, soil: 0, biodiversity: -5 }, // Methane emissions
    'wheat': { carbon: 5, water: 0, soil: 5, biodiversity: 5 },
    'maize': { carbon: 10, water: 50, soil: 0, biodiversity: 0 },
    'sorghum': { carbon: 0, water: -100, soil: 10, biodiversity: 10 }, // Drought-tolerant
    'soybeans': { carbon: -10, water: 0, soil: 15, biodiversity: 15 } // Nitrogen-fixing
  };
  
  const cropImpact = cropImpacts[farmingChoices.selectedCrop] || { carbon: 0, water: 0, soil: 0, biodiversity: 0 };
  
  carbonFootprint += cropImpact.carbon;
  waterImpact += cropImpact.water;
  soilImpact += cropImpact.soil;
  biodiversityImpact += cropImpact.biodiversity;
  
  return {
    carbonFootprint: Math.max(0, Math.round(carbonFootprint)),
    waterImpact: Math.max(0, Math.round(waterImpact)),
    soilImpact: Math.max(0, Math.min(100, Math.round(soilImpact))),
    biodiversityImpact: Math.max(0, Math.min(100, Math.round(biodiversityImpact))),
    overallScore: Math.max(0, Math.min(100, Math.round(
      (200 - carbonFootprint + (200 - waterImpact/5) + soilImpact + biodiversityImpact) / 4
    )))
  };
};